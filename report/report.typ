#import "./template.typ":report
#import "@preview/codelst:2.0.2": sourcecode, sourcefile, codelst
#import "@preview/showybox:2.0.3": showybox

#show: report.with(
  title: "Εξαμηνιαία Εργασία στα Κατανεμημένα Συστήματα",
  subtitle: "Chordify - μια P2P εφαρμογή ανταλλαγής τραγουδιών βασισμένη στο Chord DHT",
  authors: ("Λάζου Μαρία-Αργυρώ (el20129)",
            "Κατσικόπουλος Κωστής (el20103)"),
  team : "team_17",
  semester: "9ο Εξάμηνο, 2024-2025",
)

== Περιγραφή

\
Σκοπός της εργασίας είναι η σχεδίαση ενός κατανεμημένου συστήματος key-value store βασισμένο στο μοντέλο Chord DHT. με τις ακόλουθες υποστηριζόμενες λειτουργίες ανά κόμβο: 
- Join
- Depart
- Insert
- Delete
- Query 

\
Τα ήδη συνέπειας που εξετάστηκαν είναι *Eventual Consistency* και *Chain Replication*, τα οποία διαφοροποιούν τις υλοποίησεις των μεθόδων (Insert, Query, Delete) όπως περιγράφoνται παρακάτω. 

\
== Join
Για τον προσδιορισμό του ID κάθε νέου κόμβου χρησιμοποείται η συνάρτηση κατακερματισμού SHA-1 πάνω στον συνδυασμό του IP address και του TCP port που ακούει ο κόμβος. Το πρώτο μήνυμα *Join* λαμβάνεται από τον Bootsrap και προωθείται διαδοχικά σε μηνύματα τύπου *FwJoin* μέχρι να βρεθεί ο successor του. Eκείνος με την σειρά του στέλνει ένα μήνυμα *Ack* με τις σωστές πληροφορίες των γειτόνων (previous, successor), τα διαστήματα κλειδιών που διατηρεί αντίγραφα, όλα τα νεά αντίγραφα που θα αναλάβει και τα χαρακτηριστικά του δικτύου (replication factor, consistency mode).

\
== Depart 
Για την αποχώρηση κόμβου χρησιμοποιείται ένα μήνυμα *Quit*. Ύστερα, στέλνονται 2 μηνύματα *Update* στους γείτονές του για να ανανεώσουν τα πληροφορίες των previous, successor αντίστοιχα και τα διαστήματα αντιγράφων που είναι υπεύθυνοι.

\
== Replicas Transfer
Κατά τις λειτουργίες Join / Depart, απαιτείται μια αναδίαταξη των αντιγράφων στους k διαδοχικούς κόμβους η οποία ρυθμίζεται με μηνύματα τύπου *Relocate*. Για μείωση του overhead, σε κάθε μήνυμα Relocate, κάθε κόμβος μεταφέρει μόνο τα "τελευταία" αντίγραφά του (replica_idx == k) και ανανεώνει τοπικά τα indices όλων των προηγούμενων που δεν είναι γνήσια (0 < replica_idx < k). Τα μηνύματα αυτά, προωθοόυνται αναδρομικά μέχρι να φτάσουν στον τελευταίο replica manager.

#pagebreak()

== Chain Replication 
Πρόκειται για σχήμα που ακολουθεί το σ

=== Insert 

=== Query 

=== Delete 


== Eventual Consistency 
O επίσημος ορισμός του Eventual Consistency επιτρέπει την εισαγωγή κλειδιών σε οποιδήποτε replica manager και όχι μόνο στον primary node όπως αναφέρει η εκφώνηση, γεγονός που καθιστά το σύστημα περισσότερο αποδοτικό και scalable. Για τον λόγο αυτό, δίνεται ως επιπλεόν και αυτή η υλοποίηση παρόλο που εισάγει πολύ πιο σύνθετους μηχανισμούς στον κώδικά μας. Το write throughput που πετυχαίνει είναι σαφώς μεγαλύτερο.

=== Insert / Delete
Τα μηνύματα *Insert*, *Delete*, διαχειρίζονται ισότιμα από τον πρώτο κόμβο που λαμβάνει το request. Εαν αυτός είναι δυνητικά replica manager πραγματοποιεί την ζητούμενη εισαγωγή (ή διαγραφή). Σε αυτήν την περίπτωση, ο χρήστης ενημερώνεται αμέσως για την αλλαγή με μήνυμα τύπου *Reply* και έπειτα διαδίδεται στους υπόλοιπους replica managers με μήνυμα τύπου *FwInsert (FwDelete)* με lazy τρόπο. Διαφορετικά,προωθεί το ίδιο μήνυμα προς την κατεύθυνση του primary node. 

\ 
#emph[Σημείωση 1:]
Εαν ο κόμβος είναι ενδιάμεσος #emph[(0 < replica_idx < k)] χρειάζεται προώθηση και προς τις 2 κατευθύνσεις οπότε στα μηνύματα τύπου Fw χρησιμοποιούμε το πεδίο forward_back που δηλώνει την κατεύθυνση που πρέπει να προωθηθεί το επόμενο μήνυμα ώστε να αποφύγουμε τον καταιγισμό μηνυμάτων.

\
#emph[Σημείωση 2:]
Στο απλοποιημένο Eventual που ζητείται απλά προωθείται το μήνυμα *Insert* (ή *Delete*) μέχρι να βρεθεί ο primary node.

#pagebreak()

== Πειράματα 

