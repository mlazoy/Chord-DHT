#import "./template.typ":report
#import "@preview/codelst:2.0.2": sourcecode, sourcefile, codelst
#import "@preview/showybox:2.0.3": showybox

#show: report.with(
  title: "Εξαμηνιαία Εργασία στα Κατανεμημένα Συστήματα",
  subtitle: "Chordify - μια P2P εφαρμογή ανταλλαγής τραγουδιών βασισμένη στο Chord DHT",
  authors: ("Λάζου Μαρία-Αργυρώ (el20129)",
            "Κατσικόπουλος Κωστής (el20103)"),
  team : "team_17",
  semester: "9ο Εξάμηνο, 2024-2025",
)

== Περιγραφή

\
Σκοπός της εργασίας είναι η σχεδίαση ενός κατανεμημένου συστήματος key-value store βασισμένο στο μοντέλο Chord DHT. 
Όλες οι μέθοδοι και τα μηνύματα που στέλνει ο client είτε ανταλλάζουν οι κόμβοι μεταξύ τους είναι πλήρως ασύγχρονα και τρέχουν safely μέσα σε multithreaded servers (nodes). Τα δεδομένα κάθε κόμβου αποθηκεύονται σε HashMaps και η προσπέλαση τους γίνεται με την απόκτηση reader-writer locks.

\
Oι υποστηριζόμενες λειτουργίες ανά κόμβο είναι οι ακόλουθες: 
- Join
- Depart
- Insert
- Delete
- Query 

\
Τα ήδη συνέπειας που εξετάστηκαν είναι *Chain Replication* και *Eventual Consistency* , τα οποία διαφοροποιούν τις υλοποίησεις των μεθόδων (Insert, Query, Delete) όπως περιγράφoνται παρακάτω. 

\
== Join
Για τον προσδιορισμό του ID κάθε νέου κόμβου χρησιμοποείται η συνάρτηση κατακερματισμού SHA-1 πάνω στον συνδυασμό του IP address και του TCP port που ακούει ο κόμβος. Το πρώτο μήνυμα *Join* λαμβάνεται από τον Bootsrap και προωθείται διαδοχικά σε μηνύματα τύπου *FwJoin* μέχρι να βρεθεί ο successor του. Eκείνος με την σειρά του στέλνει ένα μήνυμα *Ack* με τις σωστές πληροφορίες των γειτόνων (previous, successor), τα διαστήματα κλειδιών που διατηρεί αντίγραφα (replica ranges), όλα τα νεά αντίγραφα που θα αναλάβει και τα χαρακτηριστικά του δικτύου (replication factor, consistency mode).

\
== Depart 
Για την αποχώρηση κόμβου χρησιμοποιείται ένα μήνυμα *Quit*. Ύστερα, στέλνονται 2 μηνύματα *Update* στους γείτονές του για να ανανεώσουν τα πληροφορίες των previous, successor αντίστοιχα και τα διαστήματα αντιγράφων που είναι υπεύθυνοι.

\
== Replicas Transfer
Κατά τις λειτουργίες Join / Depart, απαιτείται μια αναδίαταξη των αντιγράφων στους k διαδοχικούς κόμβους και η αλλαγή των replica ranges του κάθε κόμβου, τα οποία ρυθμίζονται με μηνύματα τύπου *Relocate*. Για μείωση του overhead, σε κάθε μήνυμα Relocate, κάθε κόμβος μεταφέρει μόνο τα "τελευταία" αντίγραφά του (replica_idx == k) και ανανεώνει τοπικά τα indices όλων των προηγούμενων που δεν είναι γνήσια (0 < replica_idx < k). Τα μηνύματα αυτά, προωθοόυνται αναδρομικά μέχρι να φτάσουν στον τελευταίο replica manager.

#pagebreak()

== Chain Replication 
Πρόκειται για σχήμα που εξασφααλίζει strong consistency με linearizability. Οι εγγραφές / διαγραφές πραγματοποιούνται μόνο από τον primary node της αλυσίδας - *head* και οι αναγνώσεις από τον τελευταίο replica manager - *tail*. Για να διαβάζουμε πάντα fresh τιμές απαιτούνται έξτρα μηχανισμοί συγχρωισμού στο head που είναι κρίσιμης σημασίας. 
\
Έστω το εξής προβληματικό σενάριο: ένας πελάτης στέλνει Insert Request σε κάποιον ενδιάμεσο κόμβο i με (0 <= i < k) και αμέσως μετά ένας άλλος στέλνει Query Requst στo tail, πρωτού προλάβει να διαδοθεί η ανανέωση του Insert που προηγήθηκε. Εαν το Query "προχωρήσει" ο πελάτης θα διαβάσει stale data. 

\
=== Query 
Προς αποφυγήν περιπτώσεων όπως η παραπάνω, εισάγουμε το πεδίο pending σε κάθε αντικέιμενο της δομής και προωθούμε όλα τα μηνύματα *Query* στο head.
Εαν το pending είναι true, το thread που διαχιρίζεται το εν λόγω Query γίνεται *schedule out* και περιμένει κατάλληλο *signal* από το λειτουργικό για να συνεχίσει την δρομολόγηση προς το tail. 

\
=== Insert
Σε κάθε μήνυμα τύπου *Insert*, το pending τίθεται σε true και η διάδοση του αντιγράφου προωθείται με *FwInsert* αναδρομικά μέχρι με το tail. Τότε ενημερώνεται ο client με μήνυμα *Reply* και ξεκινούν να στέλνονται προς τα πίσω πάλι αναδρομικά μηνύματα τύπου *AckInsert*  με τα οποία κάθε κόμβος ενημερώνει τον πρηγούμενό του για την επιτυχή εισαγωγή. Κάθε κόμβος που λαμβάνει AckInsert μαζί με το αντίστοιχο κλειδί, αλλάζει το pendig σε false και ειδοποιεί όσους readers έχουν μπλοκαριστεί από αυτό. 

\
=== Delete
Η λογική για την διάδοση ενός *Delete* και την ανανεώση του pending ακολουθεί αυτήν του Insert. Tα μηνύματα που χρησιμποιούνται εδώ είναι *FwDelete, AckDelete* αντιστοίχως. H μόνη διαφορά έγκειται στο γεγονός ότι κατά το πρώτο Delete το αντικείμενο *διαγράφεται λογικά*  (pendig = true) και η *φυσική διαγραφή* έπεται όταν λάβει το ack. 

\
\
== Eventual Consistency 
O επίσημος ορισμός του Eventual Consistency επιτρέπει την εισαγωγή κλειδιών σε οποιδήποτε replica manager και όχι μόνο στον primary node όπως αναφέρει η εκφώνηση, γεγονός που καθιστά το σύστημα περισσότερο αποδοτικό και scalable. Για τον λόγο αυτό, δίνεται ως επιπλεόν και αυτή η υλοποίηση παρόλο που εισάγει πολύ πιο σύνθετους μηχανισμούς στον κώδικά μας. Το write throughput που πετυχαίνει είναι σαφώς μεγαλύτερο.

=== Insert / Delete
Τα μηνύματα *Insert*, *Delete*, διαχειρίζονται ισότιμα από τον πρώτο κόμβο που λαμβάνει το request. Εαν αυτός είναι δυνητικά replica manager (ελέγχει εαν το ζητούμενο βρίσκεται σε κάποιο εύρος κλειδιών από όσα του αναλογούν) πραγματοποιεί την ζητούμενη εισαγωγή (ή διαγραφή). Σε αυτήν την περίπτωση, ο χρήστης ενημερώνεται αμέσως για την αλλαγή με μήνυμα τύπου *Reply* και έπειτα διαδίδεται στους υπόλοιπους replica managers με μήνυμα τύπου *FwInsert (FwDelete)* με lazy τρόπο. Διαφορετικά,προωθεί το ίδιο μήνυμα προς την κατεύθυνση του primary node. 

\ 
#emph[Σημείωση 1:]
Εαν ο κόμβος είναι ενδιάμεσος #emph[(0 < replica_idx < k)] χρειάζεται προώθηση και προς τις 2 κατευθύνσεις οπότε στα μηνύματα τύπου Fw χρησιμοποιούμε το πεδίο forward_back που δηλώνει την κατεύθυνση που πρέπει να προωθηθεί το επόμενο μήνυμα ώστε να αποφύγουμε τον καταιγισμό μηνυμάτων.

\
#emph[Σημείωση 2:]
Στο απλοποιημένο Eventual που ζητείται απλά προωθείται το μήνυμα *Insert* (ή *Delete*) μέχρι να βρεθεί ο primary node.

=== Query
Κάθε κόμβος που λαμβάνει μήνυμα *Query* ελέγχει αν βρίσκεται σε κάποιο εύρος κλειδιών από όσα του αναλογούν και είτε απαντάει με *Reply* είτε προωθεί το Query στην κατεύθυνση του primary node.

#pagebreak()

== Πειράματα 

